<!DOCTYPE html>
<html lang="en">
 <head>
  <!-- Google Analytics Tracking code -->
  <script type="text/javascript">
   var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-122966089-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();
  </script>
  <meta charset="utf-8"/>
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <meta content="Bradley Zhou" name="author"/>
  <title>
   ðŸ—‘ Threaded Garbage Collector | Bradley Zhou
  </title>
  <meta content="ðŸ—‘ Threaded Garbage Collector" property="og:title"/>
  <meta content="en_US" property="og:locale"/>
  <meta content="Threaded garbage collector for C" name="description"/>
  <meta content="Threaded garbage collector for C" property="og:description"/>
  <meta content="/garbage-collector/" property="og:url"/>
  <meta content="Bradley Zhou" property="og:site_name"/>
  <meta content="2018-05-14T00:00:00-04:00" property="article:published_time"/>
  <script type="application/ld+json">
   {"description":"Threaded garbage collector for C Pi","@type":"BlogPosting","url":"/garbage-collector/","headline":"ðŸ—‘ Threaded Garbage Collector","dateModified":"2018-12-04T00:00:00-04:00","datePublished":"2018-12-04T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"/garbage-collector/"},"@context":"http://schema.org"}
  </script>
  <link href="/garbage-collector/" rel="canonical"/>
  <link href="../assets/images/favicon/favicon-32x32.png" rel="shortcut icon" type="image/png"/>
  <link href="../assets/images/favicon/apple-touch-icon.png" rel="apple-touch-icon" sizes="72x72"/>
  <link href="../assets/images/favicon/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
  <link href="../assets/images/favicon/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/>
  <link href="../assets/images/favicon/site.webmanifest" rel="manifest"/>
  <link color="#5bbad5" href="../assets/images/favicon/safari-pinned-tab.svg" rel="mask-icon"/>
  <link href="../styles.css" rel="stylesheet"/>
 </head>
 <body>
  <div class="wrapper-large">
   <div class="page ðŸ—‘ threaded garbage collector">
    <nav class="nav">
     <ul class="list">
      <li class="item">
       <a class="link" href="../">
        Home
       </a>
      </li>
      <li class="item">
       <a class="link" href="../blog">
        Blog
       </a>
      </li>
      <li class="item">
       <a class="link" href="../projects">
        Projects
       </a>
      </li>
      <li class="item">
       <a class="link" href="../about">
        About
       </a>
      </li>
      <li class="item">
       <a class="link" href="../assets/bradley_zhou_resume.pdf">
        RÃ©sumÃ©
       </a>
      </li>
     </ul>
    </nav>
    <h1 class="title">
     ðŸ—‘ Threaded Garbage Collector
    </h1>
    <p>
     <img alt="Screenshot" src="https://raw.githubusercontent.com/bradley-z/bradley-z.github.io/master/assets/images/post_images/garbage_collector_poster.jpg"/>
    </p>
    <hr/>
    <h2 id="background">
     Background
    </h2>
    <p>
     I implemented this as my final assignment for CS 15-418: Parallel Computer Architecture and Programming. This is actually a project I've been wanting to do for a while, as the concept of garbage collection has interested me ever since I first learned about it in Computer Systems, but it wasn't until this semester that I was able to find the time/motivation to finally do it.
    </p>
    <hr/>
    <h2 id="functionality">
     Functionality
    </h2>
    <p>
     My approach started with a simple mark and sweep algorithm. The idea behind this algorithm is that memory can be viewed as a graph where blocks of memory are vertices and references from one block to another can be considered directed edges. Root nodes of the graph would be memory on the stack, registers, and global variables. The first step in the algorithm "marks" every block that can be reached by performing a DFS starting from each of the root nodes. The second step then iterates through all the heap allocated blocks of memory and then frees all blocks that have not been marked; this is the "sweep" phase. The mark phase was parallelized using pthreads: each thread was given an approximately equal number of root nodes to start the marking DFS from. Additionally, I utilized fine-grained locks in the data structures to ensure thread safety. This also allowed the sweep phase to be accelerated, as multiple frees could happen simultaneously.
    </p>
    <hr/>
    <h2 id="comments">
     Comments
    </h2>
    <p>
     The biggest limitation of mark and sweep garbage collection is that the algorithm needs to stop execution of the program in order to run the algorithm. I imagined that thread safety could eliminate this bottleneck, as multiple threads should theoretically be able to modify the list of blocks safely. I implemented this feature by just spawning a thread to run the garbage collector in parallel to the executing program, but I'm not going to claim that it works 100% correctly because I wasn't able to create a test suite comprehensive enough to test this and it seems too simple to work this way.
    </p>
    <hr/>
    <p>
     <a href="https://github.com/bradley-z/418gc">
      GitHub repo
     </a>
    </p>
    <footer class="footer-main">
     Bradley Zhou Â© 2018
    </footer>
   </div>
  </div>
 </body>
</html>
